{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"LazyTypeHint","text":"<p><code>LazyTypeHint</code> allows you to quickly generate accurate, ready-to-use type hints for any Python data structure. It supports a wide range of data types, including dictionaries, callables, Pandas DataFrames, NumPy arrays, YAML files, and more</p>"},{"location":"#rationale","title":"Rationale","text":"<p>Throughout my career in the robotics industry, I encountered numerous scenarios where working with complex and diverse data structures posed significant challenges. Configuration files were just one example\u2014from handling deeply nested dictionaries to parsing dynamic API responses, the lack of proper type hints consistently made development harder. Here\u2019s why:</p> <ul> <li>Limited IDE Assistance: Without prior knowledge of the data structure, IDE features like autocompletion and type checking are ineffective. Coding without these tools is cumbersome.</li> <li> <p>Manual Type Hints are Impractical:</p> </li> <li> <p>Time-Consuming: Extracting type hints from complex files, such as a 10,000-line     YAML file, is tedious.</p> </li> <li>Hard to Maintain: Any structural change requires team-wide updates, risking     inconsistencies and bugs.</li> <li>Comparison Challenges: Verifying that two data structures share the same structure     is non-trivial.</li> </ul> <p><code>LazyTypeHint</code> overcomes these challenges by automating type hint generation and creating reusable Python modules. This automation enhances IDE capabilities, allows static analysis (i.e type checking), and improves integration with version-control tools. Consider the following example:</p> <p></p>"},{"location":"#philosophy","title":"Philosophy","text":"<p><code>LazyTypeHint</code> is built on the following principles:</p> <ul> <li>Quick: Rapidly generate type hints for complex data structures.</li> <li>User-Friendly: Minimize complexity with intuitive methods.</li> <li>Efficiency: Simplifies and enhances type hint generation by recognizing and     consolidating equivalent sub-data structures, reducing redundancy.</li> <li>Customizable: Provide flexibility on the type hint generation for diverse use cases.</li> <li>Immutable: Maintain the integrity of input data.</li> <li>Minimal Dependencies: Keep the tool lightweight and easy to install.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Install LazyTypeHint using your preferred package manager:</p> <pre><code>pip install lazy-type-hint\n</code></pre>"},{"location":"#api","title":"API","text":"<p>The user can interact with the type hint generation via two main APIs:</p> Standard APILive API <p>Generate type hints that can be exported into a single file for reuse in your Python scripts. This approach is ideal when type hints need to be stored and tracked within a git repository. For more details, refer to the Standard API</p> <pre><code>from lazy_type_hint import LazyTypeHint, LazyTypeHintLive\n\ndata = ({\"name\": \"Peter\", \"age\": 22},) # (1)!\nLazyTypeHint().from_data(data, class_name=\"MyData\").to_file(\"file.py\") # (2)!\n</code></pre> <ol> <li>Any data structure that requires type hinting.</li> <li><code>LazyTypeHint</code> generates a Python script <code>file.py</code>, allowing you to later export    the <code>MyData</code> type alias.</li> </ol> <p>Generate type hints that are temporarily cached in the hard disk, ideal for quick data exploration. For more details, refer to the Live API.</p> <pre><code>from lazy_type_hint import LazyTypeHint, LazyTypeHintLive\n\ndata = ({\"name\": \"Peter\", \"age\": 22},) # (1)!\ndata_type_hinted = LazyTypeHintLive().from_data(data, class_name=\"MyData\") # (2)!\n</code></pre> <ol> <li>Any data structure that requires type hinting.</li> <li>The output variable retains the original data while being fully type hinted</li> </ol>"},{"location":"user_guide/configuration/","title":"Configuration","text":"<p>Although <code>lazy-type-hint</code> works seamlessly without any additional configuration, the tool offers a variety of parameters for fine-tuning type hint generation. These parameters can be passed to the initializer of both <code>LazyTypeHint</code> and <code>LazyTypeHintLive</code> via the ParsingStrategies class:</p> <pre><code>from lazy_type_hint import LazyTypeHintLive, ParsingStrategies\n\nobj = [1, 2, 3]\nobj_type_hinted =  LazyTypeHintLive(ParsingStrategies()).from_data(obj, class_name=\"MyData\")\n</code></pre>"},{"location":"user_guide/configuration/#list-strategy","title":"List Strategy","text":"<p>It can be set as: </p> ListSequence <p>Standard approach. Lists will be all hinted as <code>list[&lt;types&gt;]</code></p> <pre><code>from lazy_type_hint import LazyTypeHint, ParsingStrategies\n\nobj = [1, 2, 3]\nlazy_type_hint =  LazyTypeHint(ParsingStrategies(list_strategy=\"list\"))\nprint(lazy_type_hint.from_data(obj, class_name=\"MyData\").to_string(include_imports=False))\n\n# MyData: TypeAlias = list[int]\n</code></pre> <p>Lists will be all hinted as <code>Sequence[&lt;types&gt;]</code>. It can be helpful since <code>Sequence</code> is immutable and hence covariant.</p> <pre><code>from lazy_type_hint import LazyTypeHint, ParsingStrategies\n\nobj = [1, 2, 3]\nlazy_type_hint =  LazyTypeHint(ParsingStrategies(list_strategy=\"Sequence\"))\nprint(lazy_type_hint.from_data(obj, class_name=\"MyData\").to_string(include_imports=False))\n\n# MyData: TypeAlias = Sequence[int]\n</code></pre>"},{"location":"user_guide/configuration/#tuple-size-strategy","title":"Tuple Size Strategy","text":"FixedAny size <pre><code>from lazy_type_hint import LazyTypeHint, ParsingStrategies\n\nobj = (1, \"a\")\nlazy_type_hint =  LazyTypeHint(ParsingStrategies(tuple_size_strategy=\"fixed\"))\nprint(lazy_type_hint.from_data(obj, class_name=\"MyData\").to_string(include_imports=False))\n\n# MyData: TypeAlias = tuple[int, str]\n</code></pre> <pre><code>from lazy_type_hint import LazyTypeHint, ParsingStrategies\n\nobj = (1, \"a\")\nlazy_type_hint =  LazyTypeHint(ParsingStrategies(tuple_size_strategy=\"any size\"))\nprint(lazy_type_hint.from_data(obj, class_name=\"MyData\").to_string(include_imports=False))\n\n# MyData: TypeAlias = tuple[Union[int, str], ...]\n</code></pre>"},{"location":"user_guide/configuration/#dict-strategy","title":"Dict strategy","text":"DictMappingTypedDict <pre><code>from lazy_type_hint import LazyTypeHint, ParsingStrategies\n\ndct = {\"name\": \"Albert\", \"age\": 22}\nlazy_type_hint =  LazyTypeHint(ParsingStrategies(dict_strategy=\"dict\"))\nprint(lazy_type_hint.from_data(dct, class_name=\"MyData\").to_string(include_imports=False))\n\n# MyData: TypeAlias = dict[str, Union[int, str]]\n</code></pre> <pre><code>from lazy_type_hint import LazyTypeHint, ParsingStrategies\n\ndct = {\"name\": \"Albert\", \"age\": 22}\nlazy_type_hint =  LazyTypeHint(ParsingStrategies(dict_strategy=\"Mapping\"))\nprint(lazy_type_hint.from_data(dct, class_name=\"MyData\").to_string(include_imports=False))\n\n# MyData: TypeAlias = Mapping[str, Union[int, str]]\n</code></pre> <pre><code>from lazy_type_hint import LazyTypeHint, ParsingStrategies\n\ndct = {\"name\": \"Albert\", \"age\": 22}\nlazy_type_hint =  LazyTypeHint(ParsingStrategies(dict_strategy=\"TypedDict\"))\nprint(lazy_type_hint.from_data(dct, class_name=\"MyData\").to_string(include_imports=False))\n\n# class MyData(TypedDict):\n#     name: str\n#     age: int\n</code></pre>"},{"location":"user_guide/configuration/#pandas-strategy","title":"Pandas strategy","text":"<p>Type hinting <code>Pandas</code> objects can be challenging. To address this, three modes are available:</p> Do not type hint columnsType hint only for autocompleteFull type hint <p>...</p> <p>...</p> <p>...</p>"},{"location":"user_guide/configuration/#minimum-depth-to-define-type-alias","title":"Minimum depth to define type alias","text":"<p>type alias. This parameter defines the minimum depth a type must have to be defined as a separate type alias.</p> <pre><code>from lazy_type_hint import LazyTypeHint, ParsingStrategies\n\nobj = [22, 23, [\"Apple\", \"Banana\"]]\n\nlazy_type_hint =  LazyTypeHint(ParsingStrategies(min_depth_to_define_type_alias=2))\nprint(lazy_type_hint.from_data(obj, class_name=\"MyData\").to_string(include_imports=False))\n\n# MyData: TypeAlias = list[Union[int, list[str]]]\n\n\nlazy_type_hint =  LazyTypeHint(ParsingStrategies(min_depth_to_define_type_alias=0))\nprint(lazy_type_hint.from_data(obj, class_name=\"MyData\").to_string(include_imports=False))\n\n# MyDataList: TypeAlias = list[str]\n# MyData: TypeAlias = list[Union[MyDataList, int]]\n</code></pre>"},{"location":"user_guide/configuration/#key-used-as-doc","title":"Key used as doc","text":"<p>Certain map-based data structures, especially those derived from JSON files, may include embedded documentation within a reserved keyword. This can be specified using the <code>key_used_as_doc</code> parameter. The example below demonstrates how the docstring is attached to the <code>TypedDict</code> definition:</p> <pre><code>from lazy_type_hint import LazyTypeHint, ParsingStrategies\n\nobj = {\"value\": 2, \"doc\": \"This is documentation\"}\n\nlazy_type_hint =  LazyTypeHint(ParsingStrategies(key_used_as_doc=\"doc\"))\nprint(lazy_type_hint.from_data(obj, class_name=\"MyDict\").to_string(include_imports=False))\n\n# class MyDict(TypedDict):\n#     \"\"\"This is documentation.\"\"\"\n#\n#     value: int\n#     doc: str\n</code></pre>"},{"location":"user_guide/configuration/#merge-different-typed-dicts-if-similarity-is-above","title":"Merge different typed dicts if similarity is above","text":"<p>When loading data from YAML files, it is common to encounter list-based structures containing multiple dictionaries. Some dictionaries may have optional or missing keys, making it challenging for the algorithm to determine whether they should be declared as separate dictionaries. During the merging process, keys not present in all dictionaries are labeled as <code>NotRequired</code>. Lowering this parameter's value increases the likelihood of dictionaries being merged.</p> <pre><code>from lazy_type_hint import LazyTypeHint, ParsingStrategies\n\ndct1 = {\"name\": \"Joan\", \"age\": 22}\ndct2 = {\"name\": \"Jule\", \"age\": 19, \"children\": 2}\nobj = [dct1, dct2]\n\nlazy_type_hint =  LazyTypeHint(ParsingStrategies(merge_different_typed_dicts_if_similarity_above=99))\nprint(lazy_type_hint.from_data(obj, class_name=\"MyDict\").to_string(include_imports=False))\n\n# class MyDictDict2(TypedDict):\n#     name: str\n#     age: int\n#     children: int\n# \n# class MyDictDict(TypedDict):\n#     name: str\n#     age: int\n# \n# MyDict: TypeAlias = list[Union[MyDictDict, MyDictDict2]]\n\n\n\nlazy_type_hint =  LazyTypeHint(ParsingStrategies(merge_different_typed_dicts_if_similarity_above=30))\nprint(lazy_type_hint.from_data(obj, class_name=\"MyDict\").to_string(include_imports=False))\n\n# class MyDictDict(TypedDict):\n#   name: str\n#   age: int\n#   children: NotRequired[int]\n#\n# MyDict: TypeAlias = list[MyDictDict]\n</code></pre>"},{"location":"user_guide/configuration/#typed-dict-read-only-values","title":"Typed dict read only values","text":"FalseTrue <pre><code>from lazy_type_hint import LazyTypeHint, ParsingStrategies\n\nobj = {\"name\": \"Joan\", \"age\": 22}\n\nlazy_type_hint =  LazyTypeHint(ParsingStrategies(typed_dict_read_only_values=False))\nprint(lazy_type_hint.from_data(obj, class_name=\"MyDict\").to_string(include_imports=False))\n\n# class MyDict(TypedDict):\n#     name: str\n#     age: int\n</code></pre> <pre><code>from lazy_type_hint import LazyTypeHint, ParsingStrategies\n\nobj = {\"name\": \"Joan\", \"age\": 22}\n\nlazy_type_hint =  LazyTypeHint(ParsingStrategies(typed_dict_read_only_values=True))\nprint(lazy_type_hint.from_data(obj, class_name=\"MyDict\").to_string(include_imports=False))\n\n# class MyDict(TypedDict):\n#     name: NotRequired[str]\n#     age: NotRequired[int]\n</code></pre>"},{"location":"user_guide/configuration/#check-maximum-n-elements-within-container","title":"Check maximum n elements within container","text":"<p>To generate type hints for containers, the tool needs to analyze the types of all elements within the container. This can be computationally expensive for containers with a large number of elements. To reduce computation time, you can lower the <code>check_max_n_elements_within_container</code> parameter. However, reducing it too much might result in incorrect type hints:</p> <pre><code>from lazy_type_hint import LazyTypeHint, ParsingStrategies\n\nobj = [0, 1, \"str\"]\n\nlazy_type_hint =  LazyTypeHint(ParsingStrategies(check_max_n_elements_within_container=1))\nprint(lazy_type_hint.from_data(obj, class_name=\"MyList\").to_string(include_imports=False))\n\n# MyList: TypeAlias = list[int]\n</code></pre>"},{"location":"user_guide/introduction/","title":"Introduction","text":"<p>The user can interact this tool via two main APIs:</p> <ul> <li>Live API</li> <li>Standard API</li> </ul> <p>However, the end purpose is still the same: generating type hint information that can be used by IDEs and type checkers. Both APIs follow a common structure:</p> <pre><code>from lazy_type_hint import LazyTypeHint, LazyTypeHintLive\n\nobj_typed = LazyTypeHintLive(&lt;CONFIGURATION&gt;).from_**(&lt;PARAMS&gt;)\n</code></pre> <ol> <li>Configuration will allow the user to fine-tune the way type information is generated.    More information can be seen here</li> <li>After the tool has been instantiated, any of the <code>from_*</code> methods are available    depending on the type of input data that you want to type hint. More details are given in section below.</li> </ol>"},{"location":"user_guide/introduction/#valid-input-data","title":"Valid input data","text":"<p>This section explains different types of data that can be used as input to the tool. Be aware that, although they are written with the <code>Live API</code> for the sake of simplicity, all of these functionalities are also available within the <code>Standard API</code>. These are:</p>"},{"location":"user_guide/introduction/#from-data","title":"From data","text":"<p>User can give any Python-based data structure as input:</p> Python codeType information generatedResult <pre><code>from lazy_type_hint import LazyTypeHintLive\n\nmy_data = (\n    {\n        \"name\": \"Albert\",\n        \"age\": 22,\n        \"hobbies\": [\"swimming\", \"reading\"],\n        \"children\": {\n            \"name\": \"John\"\n        }\n    },\n    {\n        \"name\": \"Albert\",\n        \"age\": 22,\n        \"children\": {\n            \"name\": \"John\"\n        }\n    }\n)\n\nmy_data_hinted = LazyTypeHintLive().from_data(my_data, class_name=\"MyData\")\n</code></pre> <p>Since we are using the <code>Live API</code> for this example, this is the corresponding generated file that has been generated and stored in the cache-based folder:</p> <pre><code>from typing import TypedDict\nfrom typing_extensions import NotRequired, TypeAlias\n\n\nclass MyDataDictChildren(TypedDict):\n    name: str\n\n\nclass MyDataDict(TypedDict):\n    name: str\n    age: int\n    hobbies: NotRequired[list[str]]\n    children: MyDataDictChildren\n\nMyData: TypeAlias = tuple[MyDataDict, MyDataDict]\n</code></pre> <p></p>"},{"location":"user_guide/introduction/#from-yaml-file","title":"From yaml file","text":"<p>This tool internally implements its own YAML parser. This can be helpful to embed already existing comments within the YAML file and include them as part of documentation within the generated types.</p> Input YAML FilePython codeType information generatedResult <pre><code>---\n- name: Albert  # Name of the parent\nage: 22  # Age of the person\nhobbies: [swimming, reading]  # Possible hobbies\nchildren:  # Children that the parent have\n    name: John\n\n- name: Albert\nage: 22\nchildren:\n    name: John\n</code></pre> <pre><code>import yaml\n\nfrom lazy_type_hint import LazyTypeHintLive\n\n\ndef yaml_file_loader(path: str) -&gt; object:\n    with open(path) as f:\n        return yaml.load(f, Loader=yaml.SafeLoader)\n\n\nyaml_content = LazyTypeHintLive().from_yaml_file(\n    yaml_file_loader,\n    path=\"file.yaml\",\n    class_name=\"Family\",\n    comments_are=\"side\",\n)\n</code></pre> <p>Observe how the comments of the YAML file were also parsed as docstrings.</p> <p>Since we are using the <code>Live API</code> for this example, this is the corresponding generated file that has been generated and stored in the cache-based folder.</p> <pre><code>from typing import TypedDict\nfrom typing_extensions import NotRequired, TypeAlias\n\n\nclass FamilyDictChildren(TypedDict):\n    name: str\n\n\nclass FamilyDict(TypedDict):\n    name: str\n    \"\"\"Name of the parent.\"\"\"\n    age: int\n    \"\"\"Age of the person.\"\"\"\n    children: FamilyDictChildren\n    \"\"\"Children that the parent have.\"\"\"\n    hobbies: NotRequired[list[str]]\n    \"\"\"Possible hobbies.\"\"\"\n\nFamily: TypeAlias = list[FamilyDict]\n</code></pre> <p></p>"},{"location":"user_guide/live_api/","title":"Live API","text":"<p>This API generates type hints and exports the results into a cache-based folder within this package. Once the type hints are generated, this information becomes instantly available for IDEs and type checkers. Unless the cache-based folder is deleted, the generated type information can be reused at any time.</p> <p>For more details on fine-tuning the type information, see Configuration.</p>"},{"location":"user_guide/live_api/#how-to-use-it","title":"How to use it?","text":"<p>Input data to be hinted can be provided either as a Python object or from a YAML file:</p> From a Python objectFrom a YAML file <pre><code>from lazy_type_hint import LazyTypeHintLive\n\nmy_data = (\n    {\n        \"name\": \"Albert\",\n        \"age\": 22,\n        \"hobbies\": [\"swimming\", \"reading\"],\n        \"children\": {\n            \"name\": \"John\"\n        }\n    },\n    {\n        \"name\": \"Albert\",\n        \"age\": 22,\n        \"children\": {\n            \"name\": \"John\"\n        }\n    }\n)\n\nmy_data_hinted = LazyTypeHintLive().from_data(my_data, class_name=\"MyData\")\n</code></pre> <p>Keep in mind that when information is loaded from a YAML file, comments starting with <code>#</code> are parsed and used as docstrings for the corresponding data structures.</p> <pre><code>import yaml\n\nfrom lazy_type_hint import LazyTypeHint\n\n\ndef yaml_file_loader(path: str) -&gt; object:\n    with open(path) as f:\n        return yaml.load(f, Loader=yaml.SafeLoader)\n\n\nLazyTypeHint().from_yaml_file(\n    yaml_file_loader,\n    path=\"file.yaml\",\n    class_name=\"MyData\",\n    comments_are=\"side\",\n).to_file(\"my_data\")\n</code></pre>"},{"location":"user_guide/live_api/#what-are-some-of-its-potential-use-cases","title":"What are some of its potential use-cases?","text":"<p>This is ideal for data exploratory analysis when the structure of the given data is not well-defined. The corresponding type information can be interpreted by the IDE, which will provide additional functionalities such as autocompletion.</p>"},{"location":"user_guide/live_api/#how-does-it-work","title":"How does it work?","text":"<p>When the <code>Live API</code> is used:</p> <ol> <li>The type information is generated just like with the <code>Standard API</code>. This type is    identified by the literal provided in <code>class_name</code>.</li> <li>The type information is stored in a temporary folder within the library's directory.</li> <li>Stub-based files (<code>*.pyi</code>) are generated to overwrite the original interface and return    a new type when the <code>class_name</code> matches the given identifier.</li> </ol>"},{"location":"user_guide/live_api/#how-can-i-reset-the-cache-based-folder","title":"How can I reset the cache-based folder?","text":"<p>It is as simple as doing:</p> <pre><code>from lazy_type_hint import LazyTypeHintLive\n\nLazyTypeHintLive.reset()\n</code></pre> <p>This will remove all cached interfaces so far.</p>"},{"location":"user_guide/standard_api/","title":"Standard API","text":"<p>The Standard API facilitates the generation of type hints and allows exporting them as standard <code>.py</code> files.</p> <p>For detailed guidance on fine-tuning type information, refer to the Configuration section.</p>"},{"location":"user_guide/standard_api/#how-to-use-it","title":"How to use it?","text":"<p>You can provide input data for type hinting either as a Python object or by loading it from a YAML file:</p> From a Python objectFrom a YAML file <pre><code>from lazy_type_hint import LazyTypeHint\n\nmy_data = (\n    {\n        \"name\": \"Albert\",\n        \"age\": 22,\n        \"hobbies\": [\"swimming\", \"reading\"],\n        \"children\": {\n            \"name\": \"John\"\n        }\n    },\n    {\n        \"name\": \"Albert\",\n        \"age\": 22,\n        \"children\": {\n            \"name\": \"John\"\n        }\n    }\n)\n\nLazyTypeHint().from_data(my_data, class_name=\"MyData\").to_file(\"my_data.py\")\n</code></pre> <p>Keep in mind that when information is loaded from a YAML file, comments starting with <code>#</code> are parsed and used as docstrings for the corresponding data structures.</p> <pre><code>import yaml\n\nfrom lazy_type_hint import LazyTypeHintLive\n\n\ndef yaml_file_loader(path: str) -&gt; object:\n    with open(path) as f:\n        return yaml.load(f, Loader=yaml.SafeLoader)\n\n\nyaml_content = LazyTypeHintLive().from_yaml_file(\n    yaml_file_loader,\n    path=\"file.yaml\",\n    class_name=\"MyData\",\n    comments_are=\"side\",\n)\n</code></pre> <p>The code above will generate the following type interface, named <code>MyData</code>, and save it to <code>my_data.py</code>:</p> <pre><code>from typing import TypedDict\nfrom typing_extensions import NotRequired, TypeAlias\n\n\nclass MyDataDictChildren(TypedDict):\n    name: str\n\n\nclass MyDataDict(TypedDict):\n    name: str\n    age: int\n    hobbies: NotRequired[list[str]]\n    children: MyDataDictChildren\n\nMyData: TypeAlias = tuple[MyDataDict, MyDataDict]\n</code></pre> <p>With this generated type information, <code>MyData</code> can now be used to type-hint any compatible data structure:</p> <p></p>"},{"location":"user_guide/standard_api/#what-are-some-of-its-potential-use-cases","title":"What are some of its potential use-cases?","text":"<ul> <li>Data Structure Interface Generation: Complex data structures can be difficult and   time-consuming to type-hint manually. This tool generates these interfaces in   milliseconds, saving significant development effort.</li> <li>Data Structure Validation: The tool generates type information that defines the   underlying structure of a dataset. This feature allows exporting the results as a string   and comparing whether two objects share the same data structure, while ignoring value   differences.</li> <li>Static Validation: Having detailed type information enables type checkers to perform   more accurate validations, ensuring type consistency across a data structure and its   usage.</li> <li>Enhanced Development Workflow: Generated type information is recognized by IDEs,   providing autocompletion and simplifying access to complex data structures.</li> </ul>"}]}